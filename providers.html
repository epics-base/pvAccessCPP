<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>pvAccessCPP: ChannelProvider API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pvAccessCPP
   &#160;<span id="projectnumber">7.1.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ChannelProvider API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#providers_roles">Roles</a><ul><li class="level2"><a href="#provider_roles_requester">Operation and Requester</a><ul><li class="level3"><a href="#provider_roles_requester_locking"></a></li>
</ul>
</li>
<li class="level2"><a href="#providers_ownership">shared_ptr<> and Ownership</a><ul><li class="level3"><a href="#providers_ownership_unique">Uniqueness</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#providers_client">Client Role</a><ul><li class="level2"><a href="#providers_client_channel">Client Channel</a></li>
<li class="level2"><a href="#providers_client_operations">Client Operations</a><ul><li class="level3"><a href="#providers_client_operations_lifetime">Operation Lifetime and (dis)connection</a></li>
<li class="level3"><a href="#providers_client_operations_exec">Executing an Operation</a></li>
<li class="level3"><a href="#providers_client_operations_monitor">Monitor Operation</a></li>
</ul>
</li>
<li class="level2"><a href="#provides_client_ownership">Client Ownership</a></li>
<li class="level2"><a href="#provides_client_examples">Client Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#providers_server">Server Role</a></li>
</ul>
</div>
<div class="textblock"><p>The <a class="el" href="namespaceepics_1_1pv_access.html" title="Holds all PVA related. ">epics::pvAccess</a> namespace.</p>
<p>See <a class="el" href="pv_access_8h_source.html">pv/pvAccess.h</a> header.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pv/configuration.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pv/pvAccess.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pv/clientFactory.h&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="providers_roles"></a>
Roles</h1>
<p>The Client and Server APIs revolve around the <a class="el" href="classepics_1_1pv_access_1_1_channel_provider.html" title="An instance of a Client or Server. ">epics::pvAccess::ChannelProvider</a> class.</p>
<p>In the following discussion the <a class="el" href="providers.html#providers_client">Client Role</a> calls methods of ChannelProvider and associated classes. The <a class="el" href="providers.html#providers_server">Server Role</a> implements ChannelProvider and associated classes and is called by a client.</p>
<p>By convention, instances of ChannelProvider are registered and retrieved through one of <a class="el" href="classepics_1_1pv_access_1_1_channel_provider_registry.html#a17c9b397b8dbbe152f6206ea26cc9718" title="The global registry for &quot;clients&quot;. ">epics::pvAccess::ChannelProviderRegistry::clients()</a> or <a class="el" href="classepics_1_1pv_access_1_1_channel_provider_registry.html#a0d5202ac9737e8fd803304cc4f8dccc5" title="The global registry for &quot;servers&quot;. ">epics::pvAccess::ChannelProviderRegistry::servers()</a></p>
<h2><a class="anchor" id="provider_roles_requester"></a>
Operation and Requester</h2>
<p>The classes associated with ChannelProvider come in pairs. eg.</p>
<ul>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html" title="The interface through which Operations (get, put, monitor, ...) are initiated. ">epics::pvAccess::Channel</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_requester.html" title="Event notifications associated with Channel life-cycle. ">epics::pvAccess::ChannelRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_get.html" title="Request to get data from a channel. ">epics::pvAccess::ChannelGet</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_get_requester.html" title="Requester for channelGet. ">epics::pvAccess::ChannelGetRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put.html" title="Interface for a channel access put request. ">epics::pvAccess::ChannelPut</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_put_requester.html" title="Requester for ChannelPut. ">epics::pvAccess::ChannelPutRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_monitor.html" title="Access to Monitor subscription and queue. ">epics::pvAccess::Monitor</a> and <a class="el" href="classepics_1_1pv_access_1_1_monitor_requester.html" title="Callback implemented by monitor clients. ">epics::pvAccess::MonitorRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_r_p_c.html" title="Handle for an RPC operation. ">epics::pvAccess::ChannelRPC</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_r_p_c_requester.html" title="Notifications associated with Channel::createChannelRPC() ">epics::pvAccess::ChannelRPCRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_process.html" title="ChannelProcess - request that a channel be processed. ">epics::pvAccess::ChannelProcess</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_process_requester.html" title="Requester for channelProcess. ">epics::pvAccess::ChannelProcessRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get.html" title="Channel access put/get request. ">epics::pvAccess::ChannelPutGet</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_put_get_requester.html" title="Requester for ChannelPutGet. ">epics::pvAccess::ChannelPutGetRequester</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array.html" title="Request to put and get Array Data. ">epics::pvAccess::ChannelArray</a> and <a class="el" href="classepics_1_1pv_access_1_1_channel_array_requester.html" title="The Requester for a ChannelArray. ">epics::pvAccess::ChannelArrayRequester</a></li>
</ul>
<p>In the following discussions the term "Operation" refers to eg. Channel, ChannelGet, or similar while "Requester" refers to ChannelRequester, ChannelGetRequester, or similar.</p>
<p>The "Requester" classes are implemented by the Client role and called by the Server role to give notification to the client of certain events. For example, <a class="el" href="classepics_1_1pv_access_1_1_channel_requester.html#a0dff1c937999f00b0a8643bde9ea0921" title="Called occasionally after channelCreated() with Status::isOk() to give notification of connection sta...">epics::pvAccess::ChannelRequester::channelStateChange()</a> is called when a Channel becomes (dis)connected.</p>
<p>A "Requester" sub-class must be provided when each "Operation" is created. This Requester then becomes bound to the Operation.</p>
<dl class="section note"><dt>Note</dt><dd>An exception to this is <a class="el" href="classepics_1_1pv_access_1_1_channel_provider.html#a5de6d62f2f1788e887b7abdf781cc05e" title="See longer form. ">epics::pvAccess::ChannelProvider::createChannel()</a> Where a <a class="el" href="classepics_1_1pv_access_1_1_channel_requester.html" title="Event notifications associated with Channel life-cycle. ">epics::pvAccess::ChannelRequester</a> may be omitted.</dd></dl>
<p>For convenience each Operation class has a member typedef for it's associated Requester, and vis. versa. For example ChannelGet::requester_type is ChannelGetRequester and ChannelGetRequester::operation_type is ChannelGet.</p>
<h3><a class="anchor" id="provider_roles_requester_locking"></a>
provider_roles_requester_locking</h3>
<p>Operations methods may call requester methods, and vis versa. The following rules must be followed to avoid deadlocks.</p>
<ul>
<li>No locks must be held when Requester methods are called.</li>
<li>Locks may be held when Operation methods are called.</li>
</ul>
<p>These rules place the burdon of avoiding deadlocks on the ChannelProvider implementation (Server role).</p>
<p>Clients must still be aware when some Operation methods can call some Requester methods recursively, and consider this when locking.</p>
<p>For example, the following call stack may legitimetly occur for a ChannelProvider to for a Get which accesses locally stored data.</p>
<ul>
<li>Channel::createChannelGet()<ul>
<li>ChannelGetRequester::channelGetConnect()<ul>
<li>ChannelGet::get()<ul>
<li>ChannelGetRequester::getDone()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Thus care should be taken when calling ChannelGet::get() from within ChannelGetRequester::getDone() to avoid infinite recursion.</p>
<h2><a class="anchor" id="providers_ownership"></a>
shared_ptr&lt;&gt; and Ownership</h2>
<p>"Operations" and "Requesters" are always handled via std::tr1::shared_ptr.</p>
<p>In the following dicussions an instance of std::tr1::shared_ptr is referred to as a "reference", specifically a strong reference. The associated std::tr1::weak_ptr is referred to as a weak reference.</p>
<p>shared_ptr instances can exist on the stack (local variables) or as struct/class members.</p>
<p>Situations where an object contains a reference to itself, either directly or indirectly, are known as "reference loops". As long as a reference loop persists, any cleanup of resources associated with the shared_ptr (s) involved will not be done. A reference loop which is never broken is called a "reference leak".</p>
<p>In order to avoid reference leaks, required relationships between various classes will be described, and some rules stated.</p>
<p>In discussing the usage of an API diagrams like the following will be used to illustrate roles and ownership requirements.</p>
<p>The distinction of what is "user" code will depend on context. For example, when discussing the Client role, <a class="el" href="classepics_1_1pv_access_1_1_channel.html" title="The interface through which Operations (get, put, monitor, ...) are initiated. ">epics::pvAccess::Channel</a> will not be implemented by "user code". When discussing the Server role, user code will implement Channel.</p>
<h3><a class="anchor" id="providers_ownership_unique"></a>
Uniqueness</h3>
<p>A shared_ptr is said to be unique if it is the only strong reference to the underlying object. In this case shared_ptr::unique() returns true.</p>
<p>The general rule is that functions which create/allocate new objects using shared_ptr must yield a unique shared_ptr. Yielding a non-unique shared_ptr is a sign that an internal reference leak exists.</p>
<p><div class="dotgraph">
<img src="dot_ownership.png" alt="dot_ownership.png" border="0" usemap="#dot_ownership.map"/>
<map name="dot_ownership.map" id="dot_ownership.map"></map>
<div class="caption">
shared_ptr relationships</div>
</div>
</p>
<ul>
<li>A box denotes a class implemented by user code</li>
<li>An oval denotes a class not implemented by user code</li>
<li>A red line is a shared_ptr&lt;&gt;</li>
<li>A green line is a weak_ptr&lt;&gt;</li>
<li>A dashed line indicates a relationship which is outside the control of user code</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyClient {</div>
<div class="line">   epics::pvAccess::Channel::shared_ptr channel;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>MyChannelRequester : <span class="keyword">public</span> <a class="code" href="classepics_1_1pv_access_1_1_channel_requester.html">epics::pvAccess::ChannelRequester</a></div>
<div class="line">{</div>
<div class="line">    std::tr1::weak_ptr&lt;MyClient&gt; client;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classepics_1_1pv_access_1_1_channel_requester.html#a0dff1c937999f00b0a8643bde9ea0921">channelStateChange</a>(Channel::shared_pointer <span class="keyword">const</span> &amp; channel, Channel::ConnectionState connectionState) {</div>
<div class="line">        std::tr1::shared_ptr&lt;MyClient&gt; C(client.lock());</div>
<div class="line">        <span class="keywordflow">if</span>(!C) <span class="keywordflow">return</span>;</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>In this example user code implements a custom MyClient class and a sub-class of ChannelRequester in order to make use of a Channel. In order to avoid a reference loop, the sub-class of ChannelRequester uses a weak_ptr to refer to MyClient during channelStateChange() events.</p>
<h1><a class="anchor" id="providers_client"></a>
Client Role</h1>
<p>A client will by configured with a certain provider name string. It will begin by passing this string to <a class="el" href="classepics_1_1pv_access_1_1_channel_provider_registry.html#a475fcdfa41c1e2091ef9b2e30614207d" title="Creates a new instanceof the provider with the specified name. ">epics::pvAccess::ChannelProviderRegistry::createProvider()</a> to obtain a ChannelProvider instance.</p>
<p>Custom configuration of provider can be accomplished by passing a <a class="el" href="classepics_1_1pv_access_1_1_configuration.html" title="Configuration. ">epics::pvAccess::Configuration</a> to createProvider(). A Configuration is a set of string key/value parameters which the provider may use as it sees fit.</p>
<p>If a Configuration is not provided (or NULL) then the provider will use some arbitrary defaults. By convention default Configuration use the process environment.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pv/pvAccess.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pv/clientFactory.h&gt;</span></div>
<div class="line"><span class="comment">// add &quot;pva&quot; to registry</span></div>
<div class="line"><a class="codeRef" doxygen="/home/phoebus4/ANJ/epics/base/7.0/modules/pvAccess/documentation/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gac5e75a2dd40a49ee555fc35d0eeacc1a">epics::pvAccess::ClientFactory::start</a>();</div>
<div class="line"><span class="comment">// create a new client instance.</span></div>
<div class="line">epics::pvAccess::ChannelProvider::shared_pointer prov;</div>
<div class="line">prov = epics::pvAccess::getChannelProviderRegistry()-&gt;createProvider(<span class="stringliteral">&quot;pva&quot;</span>);</div>
<div class="line"><span class="comment">// createProvider() returns NULL if the named provider hasn&#39;t been registered</span></div>
<div class="line"><span class="keywordflow">if</span>(!prov)</div>
<div class="line">    <span class="keywordflow">throw</span> <a class="codeRef" doxygen="/home/phoebus4/ANJ/epics/base/7.0/modules/pvAccess/documentation/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a02920.html">std::runtime_error</a>(<span class="stringliteral">&quot;PVA provider not registered&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="providers_client_channel"></a>
Client Channel</h2>
<p>The primary (and in many cases only) ChannelProvider method of interest is <a class="el" href="classepics_1_1pv_access_1_1_channel_provider.html#a5de6d62f2f1788e887b7abdf781cc05e" title="See longer form. ">epics::pvAccess::ChannelProvider::createChannel()</a> from which a new <a class="el" href="classepics_1_1pv_access_1_1_channel.html" title="The interface through which Operations (get, put, monitor, ...) are initiated. ">epics::pvAccess::Channel</a> can be obtained.</p>
<p>Each call to createChannel() produces a "new" std::shared_ptr&lt;Channel&gt; which is uniquely owned by the caller (see <a class="el" href="providers.html#providers_ownership_unique">Uniqueness</a>). As such, the caller must keep a reference to to the Channel or it will be destroyed. This may be done explicitly, or implicitly by storing a reference to an Operation.</p>
<dl class="section note"><dt>Note</dt><dd>The returned Channel does <em>not</em> hold a strong reference for the ChannelProvider from which it was created. User code <em>must</em> keep a reference to the provider as long as Channels are in use. All Channels are automatically closed when their provider is destroyed.</dd></dl>
<p>A Channel can be created at any time, and shall succeed as long as the provided name and address are syntactically valid, and the priority is in the valid range.</p>
<p>When created, a Channel may or may not already be in the Connected state.</p>
<p>On creation <a class="el" href="classepics_1_1pv_access_1_1_channel_requester.html#aa3ac0e8a5d599bccbd4c9eb81552933b" title="The request made with ChannelProvider::createChannel() is satisfied. ">epics::pvAccess::ChannelRequester::channelCreated</a> will be called before createChannel() returns.</p>
<p>Notification of connection state changes are made through <a class="el" href="classepics_1_1pv_access_1_1_channel_requester.html#a0dff1c937999f00b0a8643bde9ea0921" title="Called occasionally after channelCreated() with Status::isOk() to give notification of connection sta...">epics::pvAccess::ChannelRequester::channelStateChange()</a> as well as through the *Connect() and channelDisconnect() methods of Requesters of any Operations on a Channel (eg. <a class="el" href="structepics_1_1pv_access_1_1_channel_base_requester.html#a6be48272a668100a47878f9446ee36b5" title="Notification when underlying Channel becomes DISCONNECTED or DESTORYED. ">epics::pvAccess::MonitorRequester::channelDisconnect()</a> ).</p>
<h2><a class="anchor" id="providers_client_operations"></a>
Client Operations</h2>
<p>This section describes commonalities between the various Operation supported: Get, Put, Monitor, RPC, PutGet, Process, and Array.</p>
<p>An Operation is created/allocated with one of the create* methods of Channel. All behave in a similar way.</p>
<ul>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#a535331a7150d313ce9b52a4d03b95af4" title="Initiate a request for a Get action. ">epics::pvAccess::Channel::createChannelGet()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#a687c724e48ce4cc3840ca4dc7b8b8ffd" title="Initiate a request for a Put action. ">epics::pvAccess::Channel::createChannelPut()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#a7da4ad844f422fc21845b1ab6931256c" title="Initiate a request for a Monitor action. ">epics::pvAccess::Channel::createMonitor()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#a5def6b52050640c936e7344955391d50" title="Initiate a request for a RPC action. ">epics::pvAccess::Channel::createChannelRPC()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#aab4a378e15ad852793fca244c8d95acd" title="Initiate a request for a PutGet action. ">epics::pvAccess::Channel::createChannelPutGet()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#a8ef64d1b0436e2c0a986038379b835dd" title="Initiate a request for a Process action. ">epics::pvAccess::Channel::createChannelProcess()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel.html#a2f1c013046d0ccbe1590a89f59f4c0b2" title="Initiate a request for a Array (get) action. ">epics::pvAccess::Channel::createChannelArray()</a></li>
</ul>
<p>The created Operation is unique (see <a class="el" href="providers.html#providers_ownership_unique">Uniqueness</a>).</p>
<p>The *Connect() method of the corresponding Requester will be called when the Operation is "ready" (underlying Channel is connected). This may happen before the create* method has returned, or at some time later.</p>
<ul>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_get_requester.html#a628b7fcb39467d2e81fd40c05978bb3b" title="The client and server have both completed the createChannelGet request. ">epics::pvAccess::ChannelGetRequester::channelGetConnect()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_requester.html#ae3f44faac0368b6a8c8585d9e1faea4a" title="The client and server have both processed the createChannelPut request. ">epics::pvAccess::ChannelPutRequester::channelPutConnect()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_monitor_requester.html#a3d37adb0afe417a003a5cffbe0ea4fd7" title="Underlying Channel is connected and operation setup is complete. ">epics::pvAccess::MonitorRequester::monitorConnect()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_r_p_c_requester.html#a7b57373d31f7bac251a1b509d3b2fa83" title="RPC creation request satisfied. ">epics::pvAccess::ChannelRPCRequester::channelRPCConnect()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get_requester.html#af4bb17db9eff63de208c7a2b1f126053" title="The client and server have both completed the createChannelPutGet request. ">epics::pvAccess::ChannelPutGetRequester::channelPutGetConnect()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_process_requester.html#a90d66f7a15ec7ff487866a7499cb676f" title="The client and server have both completed the createChannelProcess request. ">epics::pvAccess::ChannelProcessRequester::channelProcessConnect()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array_requester.html#a0817d4687d159b7e2f2fab7b8e72430b" title="Underlying Channel is connected and operation setup is complete. ">epics::pvAccess::ChannelArrayRequester::channelArrayConnect()</a></li>
</ul>
<p>When the underlying Channel becomes disconnected or is destroyed, then the channelDisconnect() method of each Requester is called (eg. see <a class="el" href="structepics_1_1pv_access_1_1_channel_base_requester.html#a6be48272a668100a47878f9446ee36b5" title="Notification when underlying Channel becomes DISCONNECTED or DESTORYED. ">epics::pvAccess::ChannelBaseRequester::channelDisconnect()</a> ). All operations are implicitly cancelled/stopped before channelDisconnect() is called.</p>
<h3><a class="anchor" id="providers_client_operations_lifetime"></a>
Operation Lifetime and (dis)connection</h3>
<p>An Operation can be created at any time regardless of whether a Channel is connected or not. An Operation will remain associated with a Channel through (re)connection and disconnection.</p>
<h3><a class="anchor" id="providers_client_operations_exec"></a>
Executing an Operation</h3>
<p>After an Operation becomes ready/connected an additional step is necessary to request data.</p>
<ul>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_get.html#a6bba1a45bb5d4e4a16f12ab9f90b3239" title="Get data from the channel. ">epics::pvAccess::ChannelGet::get()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put.html#a7af81bad03d8ed90f4093eec72b9d53b" title="Get the current data. ">epics::pvAccess::ChannelPut::get()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put.html#a59dadc01c0595e39e9f44e11b38a83e4" title="Put data to a channel. ">epics::pvAccess::ChannelPut::put()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_r_p_c.html#a3ecb36be992af9280163f14b734f6a8e" title="Issue an RPC request to the channel. ">epics::pvAccess::ChannelRPC::request()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get.html#afd659dddb7479cf85ddfe1eaf2539026" title="Issue a put/get request. ">epics::pvAccess::ChannelPutGet::putGet()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get.html#a1b9580b937bfd62a95938e281d5dfcc1" title="Get the put PVStructure. ">epics::pvAccess::ChannelPutGet::getPut()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get.html#aa362609b4d0d7b604f217c8c8322483a" title="Get the get PVStructure. ">epics::pvAccess::ChannelPutGet::getGet()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_process.html#ac031c86e6021fb0ecd8642810dd41be1" title="Issue a process request. ">epics::pvAccess::ChannelProcess::process()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array.html#a535681bb04d77a99bd562f514dee3f42" title="put to the remote array. ">epics::pvAccess::ChannelArray::putArray()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array.html#ad87e36e5f0cfc16f7eb29357053ad47e" title="get from the remote array. ">epics::pvAccess::ChannelArray::getArray()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array.html#a672e1a61da2577131c9c310260fa0771" title="Get the length. ">epics::pvAccess::ChannelArray::getLength()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array.html#a7a8baa04504351fff906dd41f301a5a6" title="Set the length and/or the capacity. ">epics::pvAccess::ChannelArray::setLength()</a></li>
</ul>
<p>Once one of these methods is called to execute an operation, none may be again until the corresponding completion callback is called, or the operation is cancel()ed (or <a class="el" href="classepics_1_1pv_access_1_1_monitor.html#a2a2eee90d2b8fe0d866d5c9f22874e3e" title="Stop Monitoring. ">epics::pvAccess::Monitor::stop()</a> ).</p>
<ul>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_get_requester.html#a482c9bfc48fe6721677f89a6cb300a4c" title="The request is done. ">epics::pvAccess::ChannelGetRequester::getDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_requester.html#aa72f7576e34f124cd9845318aeb427d7" title="The get request is done. ">epics::pvAccess::ChannelPutRequester::getDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_requester.html#a503edf348de98cd4ba3df120fc5aa0a0" title="The request is done. ">epics::pvAccess::ChannelPutRequester::putDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_r_p_c_requester.html#a87b27603927fdd1f0ce5fd7ada6fe625" title="RPC request (execution) completed. ">epics::pvAccess::ChannelRPCRequester::requestDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get_requester.html#acf95defc981104e463f64ebf2ba20c88" title="The putGet request is done. ">epics::pvAccess::ChannelPutGetRequester::putGetDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get_requester.html#a82db8664e510eb8fd70fa76baa880c04" title="The getPut request is done. ">epics::pvAccess::ChannelPutGetRequester::getPutDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_put_get_requester.html#a3a5cb6435b4f99f90571bb720c86303c" title="The getGet request is done. ">epics::pvAccess::ChannelPutGetRequester::getGetDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_process_requester.html#a9178083d581d75176b96fa6ab66cb944" title="The process request is done. ">epics::pvAccess::ChannelProcessRequester::processDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array_requester.html#ae527538df1f0171479500e9e6bc05f6e" title="The request is done. ">epics::pvAccess::ChannelArrayRequester::putArrayDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array_requester.html#aae149869e4e04f80a9c49394ec454c2c" title="The request is done. ">epics::pvAccess::ChannelArrayRequester::getArrayDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array_requester.html#ac81dc6721149cdcac5276b334dae2f26" title="The request is done. ">epics::pvAccess::ChannelArrayRequester::getLengthDone()</a></li>
<li><a class="el" href="classepics_1_1pv_access_1_1_channel_array_requester.html#a4e807572b9386cb7839bf4b5f223e43e" title="The request is done. ">epics::pvAccess::ChannelArrayRequester::setLengthDone()</a></li>
</ul>
<h3><a class="anchor" id="providers_client_operations_monitor"></a>
Monitor Operation</h3>
<p><a class="el" href="classepics_1_1pv_access_1_1_monitor.html" title="Access to Monitor subscription and queue. ">epics::pvAccess::Monitor</a> operations are handled differently than others as more than one subscription update may be delivered after <a class="elRef" doxygen="/home/phoebus4/ANJ/epics/base/7.0/modules/pvAccess/documentation/libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gac5e75a2dd40a49ee555fc35d0eeacc1a">start()</a> is called.</p>
<p>During or after <a class="el" href="classepics_1_1pv_access_1_1_monitor_requester.html#a3d37adb0afe417a003a5cffbe0ea4fd7" title="Underlying Channel is connected and operation setup is complete. ">epics::pvAccess::MonitorRequester::monitorConnect()</a> it is necessary to call <a class="el" href="classepics_1_1pv_access_1_1_monitor.html#a5a304fc626250d1e27436fb679acccad" title="Start monitoring. ">epics::pvAccess::Monitor::start()</a> to begin receiving subscription updates.</p>
<p>The <a class="el" href="classepics_1_1pv_access_1_1_monitor.html#ac422b1da19452170a5bbade584878944" title="If monitor has occurred return data. ">epics::pvAccess::Monitor::poll()</a> and <a class="el" href="classepics_1_1pv_access_1_1_monitor.html#aec3b17da9e70a7300e84f63ace464dc8" title="Release a MonitorElement that was returned by poll. ">epics::pvAccess::Monitor::release()</a> methods access a FIFO queue of subscription updates which have been received. The <a class="el" href="classepics_1_1pv_access_1_1_monitor_requester.html#a2f638b98f355e73c24cf232cf7f9a69b" title="Monitor queue is not empty. ">epics::pvAccess::MonitorRequester::monitorEvent()</a> method is called when this FIFO becomes not empty.</p>
<dl class="section note"><dt>Note</dt><dd>The pvAccess::MonitorRequester::monitorEvent() is called from a server internal thread which may be shared with other operations. In order to avoid delaying other channels/operations it is recommended to use monitorEvent() as notification for a client specific worker thread where poll() and release() are called.</dd></dl>
<p><a class="el" href="classepics_1_1pv_access_1_1_monitor_requester.html#ab13880f6f55d63c23b80989b7a23e30d" title="No more subscription update will be sent. ">epics::pvAccess::MonitorRequester::unlisten()</a> is called to indicate a subscription has reached a definite end without an error. Not all subscription sources will use this.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is critical that any non-NULL MonitorElement returned by poll() must be passed to release(). Failure to do this will result in a resource leak and possibly stall the monitor. See epics::pvAccess::Monitor::Stats::noutstanding</dd></dl>
<p>epics::pvAccess::Monitor::getStats() can help diagnose problems related to the Monitor FIFO. See epics::pvAccess::Monitor::Stats.</p>
<h2><a class="anchor" id="provides_client_ownership"></a>
Client Ownership</h2>
<p>The following shows the implicit ownership in classes outside the control of client code, as well as the expected ownerships of of Client user code. "External" denotes references stored by Client objects which can't participate in reference cycles.</p>
<p><div class="dotgraph">
<img src="dot_client_ownership.png" alt="dot_client_ownership.png" border="0" usemap="#dot_client_ownership.map"/>
<map name="dot_client_ownership.map" id="dot_client_ownership.map"></map>
<div class="caption">
Client implicit relationships</div>
</div>
</p>
<ul>
<li>Channel holds weak ref. to ChannelProvider</li>
<li>ChannelProvider holds weak ref. to Channel</li>
<li>Channel holds weak ref. to ChannelRequester</li>
<li>Channel holds weak refs to all Operations</li>
<li>Operations hold weak refs to the corresponding Requester, and Channel</li>
</ul>
<h2><a class="anchor" id="provides_client_examples"></a>
Client Examples</h2>
<ul>
<li><a class="el" href="examples_getme.html">Client Get Example</a></li>
<li><a class="el" href="examples_monitorme.html">Client Monitor Example</a></li>
</ul>
<h1><a class="anchor" id="providers_server"></a>
Server Role</h1>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 18 2023 14:51:35 for pvAccessCPP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
